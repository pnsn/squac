<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>squac documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avaoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);

               if ($darkModeToggles.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-block d-sm-none">
            <a href="../" class="navbar-brand">squac documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  ChannelData</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/widgets/src/lib/widget-types/map/map.component.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#nslc" 
>
                                            nslc
                                        </a>
                                </li>
                                <li>
                                        <a href="#value" 
>
                                            value
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="nslc"></a>
                                        <span class="name "><b>nslc</b>
                                            <a href="#nslc">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>nslc:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="value"></a>
                                        <span class="name "><b>value</b>
                                            <a href="#value">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>value:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  NgZone,
  OnDestroy,
  OnInit,
  ViewChild,
} from &quot;@angular/core&quot;;
import { PrecisionPipe } from &quot;../../pipes/precision.pipe&quot;;

import {
  WidgetConnectService,
  WidgetManagerService,
  WidgetConfigService,
} from &quot;../../services&quot;;
import {
  isPiecewise,
  VisualMapTypes,
  WidgetTypeComponent,
  isContinuous,
  isStoplight,
} from &quot;../../interfaces&quot;;
import { GenericWidgetComponent } from &quot;../../components&quot;;
import { StationRow } from &quot;./types&quot;;
import { Channel, MeasurementPipe, MeasurementTypes, Metric } from &quot;squacapi&quot;;
import {
  Control,
  divIcon,
  FeatureGroup,
  featureGroup,
  latLng,
  LatLngBounds,
  LayerGroup,
  Map,
  MapOptions,
  Marker,
  marker,
  MarkerOptions,
  tileLayer,
} from &quot;leaflet&quot;;
import { NgFor, NgIf } from &quot;@angular/common&quot;;
import { LeafletDrawModule } from &quot;@asymmetrik/ngx-leaflet-draw&quot;;
import { LeafletModule } from &quot;@asymmetrik/ngx-leaflet&quot;;
import { GuardTypePipe } from &quot;../../pipes/guard-type.pipe&quot;;

interface ChannelData {
  nslc: string;
  value: number;
}
interface StationData {
  staCode: string;
  channelData: ChannelData[];
  lat: number;
  lon: number;
}

/**
 * Leaflet map widget that displays stations
 */
@Component({
  selector: &quot;widget-map&quot;,
  templateUrl: &quot;./map.component.html&quot;,
  styleUrls: [&quot;./map.component.scss&quot;],
  standalone: true,
  imports: [
    NgFor,
    LeafletDrawModule,
    LeafletModule,
    PrecisionPipe,
    NgIf,
    GuardTypePipe,
  ],
})
export class MapComponent
  extends GenericWidgetComponent
  implements OnInit, OnDestroy, WidgetTypeComponent
{
  /** element of legend on map*/
  @ViewChild(&quot;legendElement&quot;, { static: false }) public legendRef: ElementRef;
  /** map element ref */
  @ViewChild(&quot;mapElement&quot;, { static: false }) public mapRef: ElementRef;

  /** observer for page resizes */
  resizeObserver: ResizeObserver;
  /** station layers on map */
  stationLayer: LayerGroup;
  /** metric to display on map */
  displayMetric: Metric;
  /** Map configuration options */
  options: MapOptions;
  /** Map config for drawing */
  drawOptions: Record&lt;string, never&gt;;
  /** layers to display on map */
  layers: FeatureGroup[];
  /** map bounds */
  fitBounds: LatLngBounds;
  /** leaflet map instance */
  map: Map;
  /** map layers grouped by metric */
  metricLayers: Record&lt;number, Marker[]&gt;;
  /** Visual map for coloring icons */
  displayMap: VisualMapTypes;
  /** leaflet legend control */
  legend: Control;
  /** Station data */
  stations: StationRow[];
  /** transform measurements */
  measurementPipe &#x3D; new MeasurementPipe();
  /** pipe for calculating prescisions */
  precisionPipe &#x3D; new PrecisionPipe();

  /** typeguards */
  isPiecewise &#x3D; isPiecewise;
  isStoplight &#x3D; isStoplight;
  isContinuous &#x3D; isContinuous;

  constructor(
    private widgetConfigService: WidgetConfigService,
    protected widgetConnectService: WidgetConnectService,
    override widgetManager: WidgetManagerService,
    protected zone: NgZone,
    override cdr: ChangeDetectorRef
  ) {
    super(widgetManager, widgetConnectService, zone);
  }

  /**
   * override to disable method
   *
   * @param _useDenseView unused
   */
  override useDenseView(_useDenseView: boolean): void {
    return;
  }

  /**
   * override to disable method
   *
   * @param _channel unused
   */
  deemphasizeChannel(_channel: string): void {
    return;
  }

  /**
   * Should trigger zoom, but currently not available
   */
  startZoom(): void {
    return;
  }

  /**
   * @override
   */
  configureChart(): void {
    // Add all the layers to the array that will be fed to options
    const baseLayers &#x3D; [
      tileLayer(&quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;, {
        attribution:
          &#x27;&amp;copy; &lt;a href&#x3D;&quot;http://www.openstreetmap.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt;&#x27;,
      }),
    ];

    this.options &#x3D; {
      center: latLng(0, 0),
      zoom: 5,
      layers: baseLayers,
      doubleClickZoom: false,
      preferCanvas: true,
    };
  }

  /**
   * Update widget data
   *
   * @param data - data for widget to update
   */
  override updateData(data: MeasurementTypes[]): void {
    //overridden to allow check for if map exists
    this.data &#x3D; data;
    this.channels &#x3D; this.widgetManager.channels;
    this.selectedMetrics &#x3D; this.widgetManager.selectedMetrics;
    this.properties &#x3D; this.widgetManager.properties;
    if (this.map) {
      this.changeData(data);
    }
  }

  /**
   * trigger chart data set up &amp; change metrics
   *
   * @param data data to add to the chart
   */
  changeData(data: MeasurementTypes[]): void {
    this.buildChartData(data).then(() &#x3D;&gt; {
      this.changeMetrics();
      this.cdr.detectChanges();
      this.data &#x3D; null;
    });
  }

  /**
   * @override
   */
  toggleKey(): void {
    //show
    if (this.showKey &amp;&amp; this.map) {
      this.legend.addTo(this.map);
    } else if (this.legend) {
      this.legend.remove();
    }
  }

  /**
   * Store map once ready
   *
   * @param map - Leaflet map referencea
   */
  onMapReady(map: Map): void {
    this.map &#x3D; map;
    // Do stuff with map
    if (this.selectedMetrics.length &gt; 0) {
      this.legend &#x3D; new Control({
        position: &quot;topright&quot;,
      });
      this.changeData(this.data);
    }
  }

  /**
   * emphasize channel on map
   *
   * @param channel nslc to emphasize
   */
  emphasizeChannel(channel: string): void {
    // const layer &#x3D; this.metricLayers[this.displayMetric.id];
    if (channel &amp;&amp; this.stations) {
      const chan &#x3D; channel.split(&quot;.&quot;);
      const stationId &#x3D; chan[0] + &quot;.&quot; + chan[1];

      const stationIndex &#x3D; this.stations.findIndex((station) &#x3D;&gt; {
        return station.id &#x3D;&#x3D;&#x3D; stationId;
      });
      const layer &#x3D; this.metricLayers[this.displayMetric.id];
      layer.forEach((marker, index) &#x3D;&gt; {
        if (index !&#x3D;&#x3D; stationIndex) {
          marker.closeTooltip();
        } else {
          const position &#x3D; marker.getLatLng();
          this.map.setView(position);
          marker.openTooltip();
        }
      });
    }
  }

  /**
   * set up legend element and add to map
   */
  private initLegend(): void {
    const legend &#x3D; this.legendRef?.nativeElement;
    this.legend.onAdd &#x3D; (): HTMLElement &#x3D;&gt; {
      return legend;
    };
    // only add legend to map if the map is ready
    // throws errors otherwise
    if (this.map &amp;&amp; legend &amp;&amp; this.showKey) {
      this.legend.addTo(this.map);
    }
  }

  /**
   * Toggle map pane with inputted color
   *
   * @param pane - string name of pane (will be color)
   */
  toggleColor(pane: string): void {
    const pane1 &#x3D; this.map.getPane(pane);
    pane1.classList.toggle(&quot;hidden&quot;);
    const el &#x3D; this.mapRef.nativeElement.getElementsByClassName(pane);
    if (el[0]) {
      el[0].classList.toggle(&quot;layer-hidden&quot;);
    }
    if (el[1]) {
      el[1].classList.toggle(&quot;layer-hidden&quot;);
    }
  }

  /**
   * Toggle individual station, currently unused
   *
   * @param i - index of station
   * @param event - click event
   */
  toggleStation(i: number, event: any): void {
    event.preventDefault();
    const el &#x3D; this.mapRef.nativeElement.getElementsByClassName(i)[0];
    const layer &#x3D; this.metricLayers[this.displayMetric.id];
    const station &#x3D; layer[i];
    if (this.layers[0].hasLayer(station)) {
      this.layers[0].removeLayer(station);
      el.classList.add(&quot;layer-hidden&quot;);
    } else {
      this.layers[0].addLayer(station);

      el.classList.remove(&quot;layer-hidden&quot;);
    }

    event.stopPropagation();
    // ;
  }

  /**
   * Remove resize observer when map destroyed
   */
  override ngOnDestroy(): void {
    this.map &#x3D; null;
    if (this.resizeObserver) {
      this.resizeObserver.unobserve(this.mapRef.nativeElement);
    }
    super.ngOnDestroy();
  }

  /**
   * Creates map markers using processed data
   *
   * @param data processed data from request
   */
  buildChartData(data: MeasurementTypes[]): Promise&lt;void&gt; {
    return new Promise&lt;void&gt;((resolve) &#x3D;&gt; {
      this.data &#x3D; data;
      this.metricLayers &#x3D; {};

      this.selectedMetrics.forEach((metric) &#x3D;&gt; {
        if (!metric) return;
        const stationsData: StationData[] &#x3D; [];
        this.channels.forEach((channel: Channel) &#x3D;&gt; {
          let stationData &#x3D; stationsData.find(
            (s) &#x3D;&gt; channel.staCode &#x3D;&#x3D;&#x3D; s.staCode
          );
          if (!stationData) {
            stationData &#x3D; {
              staCode: channel.staCode,
              channelData: [],
              lat: channel.lat,
              lon: channel.lon,
            };
            stationsData.push(stationData);
          }
          let val: number &#x3D; null;

          const channelData &#x3D; data
            .filter((m) &#x3D;&gt; m.channel &#x3D;&#x3D;&#x3D; channel.id &amp;&amp; m.metric &#x3D;&#x3D;&#x3D; metric.id)
            .map((m) &#x3D;&gt; {
              m.value &#x3D; m.value ?? m[this.widgetManager.dataStat];
              return m;
            });

          val &#x3D; this.measurementPipe.transform(
            channelData,
            this.widgetManager.stat
          );

          this.widgetConfigService.calculateDataRange(metric.id, val);

          stationData.channelData.push({
            nslc: channel.nslc,
            value: val,
          });

          // check if agg if worse than current agg
        });

        const visualMap &#x3D; this.widgetConfigService.getVisualMapFromThresholds(
          [metric],
          this.properties,
          3
        )[metric.id];

        const stationMarkers &#x3D; [];
        stationsData.forEach((station: StationData) &#x3D;&gt; {
          // count of channels that are null or out of spec
          let outOfSpecChannels &#x3D; 0;
          let stationHTML &#x3D; &quot;&quot;;
          let stationColor: string;

          let stationValue &#x3D; Number.MIN_SAFE_INTEGER;

          station.channelData.forEach((channelData) &#x3D;&gt; {
            stationValue &#x3D; Math.max(Math.abs(channelData.value), stationValue);

            const val &#x3D; channelData.value;
            const inRange &#x3D; visualMap
              ? this.widgetConfigService.checkValue(val, visualMap)
              : true;

            if (val &#x3D;&#x3D;&#x3D; null || (visualMap &amp;&amp; !inRange)) {
              outOfSpecChannels++;
            }

            const color &#x3D; this.getStyle(val, visualMap);
            const iconHtml &#x3D; this.getIconHtml(color);

            stationHTML +&#x3D; &#x60;&lt;tr&gt; &lt;td&gt; ${iconHtml} ${
              channelData.nslc
            } &lt;/td&gt;&lt;td&gt; ${
              val !&#x3D;&#x3D; null ? this.precisionPipe.transform(val) : &quot;no data&quot;
            }&lt;/td&gt;&lt;/tr&gt;&#x60;;
          });

          if (isStoplight(visualMap)) {
            if (outOfSpecChannels &#x3D;&#x3D;&#x3D; 0) {
              stationColor &#x3D; visualMap.colors.in;
            } else if (outOfSpecChannels &#x3D;&#x3D;&#x3D; station.channelData.length) {
              stationColor &#x3D; visualMap.colors.out;
            } else {
              stationColor &#x3D; visualMap.colors.middle;
            }
          } else {
            stationColor &#x3D; this.getStyle(stationValue, visualMap);
          }

          //each layer is own feature group
          stationMarkers.push(
            this.makeStationMarker(station, stationHTML, stationColor)
          );
        });

        this.visualMaps[metric.id] &#x3D; visualMap;
        this.metricLayers[metric.id] &#x3D; stationMarkers;
      });
      resolve();
    });
  }

  /**
   * Add panes to map
   *
   * @param visualMap - visual map type
   */
  addPanes(visualMap: VisualMapTypes): void {
    if (visualMap) {
      switch (visualMap.type) {
        case &quot;stoplight&quot;:
          if (&quot;colors&quot; in visualMap) {
            this.map.createPane(visualMap.colors.in);
            this.map.createPane(visualMap.colors.out);
            this.map.createPane(visualMap.colors.middle);
          }
          break;
        case &quot;continuous&quot;:
          visualMap.inRange.color.forEach((color) &#x3D;&gt; {
            this.map.createPane(color);
          });
          this.map.createPane(visualMap.outOfRange.color[0]);
          break;
        case &quot;piecewise&quot;:
          if (&quot;pieces&quot; in visualMap) {
            visualMap.pieces.forEach((piece) &#x3D;&gt; {
              this.map.createPane(piece.color);
            });
          }
          this.map.createPane(visualMap.outOfRange.color[0]);

          break;
      }
    } else {
      //no visual map
      this.map.createPane(&quot;gray&quot;);
    }

    this.map.createPane(&quot;nodata&quot;); //no data pane
  }

  /**
   * Change metric to show on the map and resize after
   */
  changeMetrics(): void {
    this.displayMetric &#x3D; this.selectedMetrics[0];
    this.displayMap &#x3D; this.visualMaps[this.displayMetric.id];
    this.addPanes(this.displayMap);
    this.layers &#x3D; [featureGroup(this.metricLayers[this.displayMetric.id])];
    this.initLegend();
    this.fitBounds &#x3D; this.layers[0].getBounds();

    this.resizeObserver &#x3D; new ResizeObserver(() &#x3D;&gt; {
      if (this.map) {
        this.map.invalidateSize();
      }
      this.fitBounds &#x3D; this.layers[0].getBounds();
    });

    this.resizeObserver.observe(this.mapRef.nativeElement);
  }

  /**
   * Returns html string for map icon
   *
   * @param color - string color of icon
   * @returns html string for map icon
   */
  private getIconHtml(color?: string): string {
    let htmlString &#x3D; &#x60;&lt;div style&#x3D;&#x27;background-color: ${color}&#x27; class&#x3D;&#x27;map-icon &#x60;;
    if (color &#x3D;&#x3D;&#x3D; &quot;white&quot; || color &#x3D;&#x3D;&#x3D; &quot;transparent&quot;) {
      htmlString +&#x3D; &quot;border&quot;;
    }
    htmlString +&#x3D; &#x60;&#x27;&gt;&lt;/div&gt;&#x60;;
    return htmlString;
  }

  /**
   * Finds correct color for given value based on visualmap
   *
   * @param value - value to check
   * @param visualMap - visual map to use
   * @returns string color
   */
  private getStyle(value: number, visualMap: VisualMapTypes): string {
    if (
      value &#x3D;&#x3D;&#x3D; Number.MIN_SAFE_INTEGER ||
      value &#x3D;&#x3D;&#x3D; null ||
      value &#x3D;&#x3D;&#x3D; undefined
    ) {
      return &quot;transparent&quot;;
    }
    return this.widgetConfigService.getColorFromValue(value, visualMap);
  }

  /**
   * Makes leaflet marker for a station
   *
   * @param station - station to make marker for
   * @param stationHTML - station channels string
   * @param stationColor - string color
   * @returns leaflet marker for map
   */
  private makeStationMarker(
    station: StationData,
    stationHTML: string,
    stationColor: string
  ): Marker {
    const options: MarkerOptions &#x3D; {
      autoPan: true,
      riseOnHover: true,
    };
    let html: string;
    if (stationColor) {
      html &#x3D; this.getIconHtml(stationColor);
      if (stationColor &#x3D;&#x3D;&#x3D; &quot;transparent&quot;) {
        options.pane &#x3D; &quot;nodata&quot;;
      } else {
        options.pane &#x3D; stationColor;
      }
    } else {
      html &#x3D; this.getIconHtml(&quot;white&quot;);
    }

    options.icon &#x3D; divIcon({ html, className: &quot;icon-parent&quot; });
    const markerObj &#x3D; marker([station.lat, station.lon], options).bindTooltip(
      &#x60;&lt;div class&#x3D;&#x27;tooltip-name&#x27;&gt; ${station.staCode} &lt;/div&gt; &lt;table class&#x3D;&#x27;tooltip-table&#x27;&gt;
        &lt;thead&gt;&lt;th&gt;Channel&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/thead&gt;&lt;tbody&gt;
      ${stationHTML}&lt;/tbody&gt; &lt;/table&gt;&#x60;
    );
    markerObj.on(&quot;click&quot;, (ev) &#x3D;&gt; {
      ev.target.openPopup();
    });
    return markerObj;
  }
}
//no data, empty (?) white circle
//skip no data and show channel with data
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ChannelData-1.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
