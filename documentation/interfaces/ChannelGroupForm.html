<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>squac documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">squac documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  ChannelGroupForm</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/squac-ui/src/app/features/channel-group/components/channel-group-edit/channel-group-edit.component.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Channel group edit form</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#description" 
>
                                            description
                                        </a>
                                </li>
                                <li>
                                        <a href="#name" 
>
                                            name
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="description"></a>
                                        <span class="name "><b>description</b>
                                            <a href="#description">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>description:     <code>FormControl&lt;string&gt;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>FormControl&lt;string&gt;</code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>channel group description</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="name"></a>
                                        <span class="name "><b>name</b>
                                            <a href="#name">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>name:     <code>FormControl&lt;string&gt;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>FormControl&lt;string&gt;</code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>channel group name</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, OnInit, OnDestroy, ViewChild } from &quot;@angular/core&quot;;
import { Router, ActivatedRoute } from &quot;@angular/router&quot;;
import { ChannelGroup } from &quot;squacapi&quot;;
import { ChannelGroupService } from &quot;squacapi&quot;;
import {
  Validators,
  FormControl,
  FormGroup,
  FormBuilder,
} from &quot;@angular/forms&quot;;
import { ChannelService } from &quot;squacapi&quot;;
import { Channel } from &quot;squacapi&quot;;
import { Subscription, switchMap, tap, merge, of } from &quot;rxjs&quot;;
import {
  ColumnMode,
  SelectionType,
  SortType,
} from &quot;@boring.devs/ngx-datatable&quot;;
import { UserService } from &quot;@user/services/user.service&quot;;
import { ConfirmDialogService } from &quot;@core/services/confirm-dialog.service&quot;;
import { MessageService } from &quot;@core/services/message.service&quot;;
import { MatchingRuleService } from &quot;squacapi&quot;;
import { MatchingRule } from &quot;squacapi&quot;;
import { DateService } from &quot;@core/services/date.service&quot;;
import { LoadingService } from &quot;@core/services/loading.service&quot;;
import { MapBounds } from &quot;../channel-group-map/interfaces&quot;;
import { SearchFilter } from &quot;./interfaces&quot;;
import {
  ButtonEvent,
  PageOptions,
} from &quot;@shared/components/detail-page/detail-page.interface&quot;;
import { FilterText } from &quot;@shared/components/sharing-toggle/sharing-toggle.interface&quot;;

/** Loading indicator areas */
enum LoadingIndicator {
  MAIN,
  RESULTS,
}

/** Channel group edit form */
interface ChannelGroupForm {
  /** channel group name */
  name: FormControl&lt;string&gt;;
  /** channel group description */
  description: FormControl&lt;string&gt;;
}
/**
 * Channel group editing component
 */
@Component({
  selector: &quot;channel-group-edit&quot;,
  templateUrl: &quot;./channel-group-edit.component.html&quot;,
  styleUrls: [&quot;./channel-group-edit.component.scss&quot;],
})
// TODO: this is getting massive - consider restructuring
export class ChannelGroupEditComponent implements OnInit, OnDestroy {
  subscriptions: Subscription &#x3D; new Subscription();
  LoadingIndicator &#x3D; LoadingIndicator;
  id: number;
  channelGroup: ChannelGroup;
  editMode: boolean; //create group or edit group
  error: boolean | string &#x3D; false;
  changeMade &#x3D; false;
  orgId: number;
  showOnlyCurrent &#x3D; true; // Filter out not-current channels
  searchFilters: SearchFilter;
  channelGroupForm: FormGroup&lt;ChannelGroupForm&gt;; // form stuff
  csvStatus: string;
  channelsInGroup: Channel[] &#x3D; []; // channels currently saved in group
  selectedChannels: Channel[] &#x3D; []; // Channels currently in selected list
  selectedInGroupChannels: Channel[] &#x3D; []; // Channels selected from group table
  previousChannels: Channel[]; // Store last version of channels for undo

  shareOrg &#x3D; false;
  shareAll &#x3D; false;
  // Map stuff
  showChannel: Channel; // Channel to show on map
  bounds: MapBounds; // Latlng bounds to either filter by or make a new request with

  // table config
  SelectionType &#x3D; SelectionType;
  ColumnMode &#x3D; ColumnMode;
  SortType &#x3D; SortType;
  columns: any &#x3D; [];
  rows: Channel[] &#x3D; [];
  deleteMatchingRulesIds &#x3D; [];

  lastState: {
    selectedChannels: Channel[];
    autoIncludeChannels: Channel[];
    autoExcludeChannels: Channel[];
  };
  matchingRules: MatchingRule[] &#x3D; [];
  autoIncludeChannels: Channel[] &#x3D; [];
  autoExcludeChannels: Channel[] &#x3D; [];
  @ViewChild(&quot;availableTable&quot;) availableTable: any;
  @ViewChild(&quot;selectedTable&quot;) selectedTable: any;

  /** Config for detail page */
  pageOptions: PageOptions &#x3D; {
    titleButtons: {
      cancelButton: true,
      deleteButton: true,
    },
    path: &quot;/channel-groups&quot;,
  };

  sharedToggleConfig: FilterText &#x3D; {
    user: &quot;Private&quot;,
    all: &quot;Public&quot;,
  };

  constructor(
    private router: Router,
    private route: ActivatedRoute,
    private channelGroupService: ChannelGroupService,
    private channelService: ChannelService,
    private formBuilder: FormBuilder,
    private userService: UserService,
    private confirmDialog: ConfirmDialogService,
    private messageService: MessageService,
    private matchingRuleService: MatchingRuleService,
    private dateService: DateService,
    public loadingService: LoadingService
  ) {}

  /**
   * Subscribe to route params
   */
  ngOnInit(): void {
    this.channelGroupForm &#x3D; this.formBuilder.group({
      name: new FormControl(&quot;&quot;, Validators.required),
      description: new FormControl(&quot;&quot;, Validators.required),
    });

    const routeSub &#x3D; this.route.data
      .pipe(
        tap((data: any) &#x3D;&gt; {
          this.channelGroup &#x3D; data[&quot;channelGroup&quot;];
          this.matchingRules &#x3D; data[&quot;matchingRules&quot;] || [];
          this.editMode &#x3D; !!this.channelGroup;
          this.id &#x3D; this.channelGroup?.id;
          this.pageOptions.titleButtons.deleteButton &#x3D; this.editMode;
        })
      )
      .subscribe({
        next: () &#x3D;&gt; {
          this.initForm();
        },
      });

    this.subscriptions.add(routeSub);

    // get orgId
    this.orgId &#x3D; this.userService.userOrg;

    // table columns
    this.columns &#x3D; [
      {
        width: 30,
        canAutoResize: false,
        sortable: false,
        draggable: false,
        resizeable: false,
        headerCheckboxable: true,
        checkboxable: true,
      },

      {
        name: &quot;Network&quot;,
        prop: &quot;net&quot;,
        draggable: false,
        sortable: true,
        resizeable: false,
        flexGrow: 1,
      },
      {
        name: &quot;Station&quot;,
        prop: &quot;net&quot;,
        draggable: false,
        sortable: true,
        resizeable: false,
        flexGrow: 1,
      },
      {
        name: &quot;Location&quot;,
        prop: &quot;loc&quot;,
        draggable: false,
        sortable: true,
        resizeable: false,
        flexGrow: 1,
      },
      {
        name: &quot;Channel&quot;,
        prop: &quot;code&quot;,
        draggable: false,
        sortable: true,
        resizeable: false,
        flexGrow: 1,
      },
    ];
  }

  /**
   * Inits group edit form
   */
  private initForm(): void {
    // if editing existing group, populate with the info
    if (this.editMode) {
      this.channelGroupForm.patchValue({
        name: this.channelGroup.name,
        description: this.channelGroup.description,
      });
      this.shareAll &#x3D; this.channelGroup.shareAll;
      this.shareOrg &#x3D; this.channelGroup.shareOrg;
      this.autoExcludeChannels &#x3D; [
        ...this.channelGroup.autoExcludeChannels,
      ] as Channel[];
      this.autoIncludeChannels &#x3D; [
        ...this.channelGroup.autoIncludeChannels,
      ] as Channel[];
    }
  }

  /**
   * Control clicked on header
   *
   * @param type type of button click
   */
  controlClicked(type: ButtonEvent): void {
    if (type &#x3D;&#x3D;&#x3D; &quot;delete&quot;) {
      this.delete();
    } else if (type &#x3D;&#x3D;&#x3D; &quot;cancel&quot;) {
      this.cancel();
    } else if (type &#x3D;&#x3D;&#x3D; &quot;save&quot;) {
      this.save();
    }
  }

  /**
   * Add auto included channels
   */
  includeChannels(): void {
    this.updateState();

    //get all channels that aren&#x27;t already in add channels
    const addChannels &#x3D; this.findChannelsInGroup(this.autoIncludeChannels);

    // add channels
    this.autoExcludeChannels &#x3D; this.autoExcludeChannels.filter((channel) &#x3D;&gt; {
      const index &#x3D; addChannels.findIndex((c) &#x3D;&gt; c.id &#x3D;&#x3D;&#x3D; channel.id);
      return index &#x3D;&#x3D;&#x3D; -1;
    });

    this.autoIncludeChannels &#x3D; [...this.autoIncludeChannels, ...addChannels];
    //remove from excluded
    this.selectedChannels &#x3D; [];
  }

  /**
   * add auto excluded channels
   */
  excludeChannels(): void {
    this.updateState();
    const addChannels &#x3D; this.findChannelsInGroup(this.autoExcludeChannels);

    this.autoIncludeChannels &#x3D; this.autoIncludeChannels.filter((channel) &#x3D;&gt; {
      const index &#x3D; addChannels.findIndex((c) &#x3D;&gt; c.id &#x3D;&#x3D;&#x3D; channel.id);
      return index &#x3D;&#x3D;&#x3D; -1;
    });

    this.autoExcludeChannels &#x3D; [...this.autoExcludeChannels, ...addChannels];
    //remove from included
    this.selectedChannels &#x3D; [];
  }

  /**
   * Returns channels that are not already in the given group
   *
   * @param group group of channels
   * @returns all selected channels not in group
   */
  private findChannelsInGroup(group): Channel[] {
    return this.selectedChannels.filter((channel) &#x3D;&gt; {
      const index &#x3D; group.findIndex((c) &#x3D;&gt; c.id &#x3D;&#x3D;&#x3D; channel.id);
      return index &#x3D;&#x3D;&#x3D; -1;
    });
  }

  /**
   * Undo changes by restoring last version
   */
  undoSelectRemove(): void {
    this.autoExcludeChannels &#x3D; this.lastState.autoExcludeChannels;
    this.autoIncludeChannels &#x3D; this.lastState.autoIncludeChannels;
    this.selectedChannels &#x3D; this.lastState.selectedChannels;

    this.updateState();
    this.changeMade &#x3D; false;
  }

  /**
   * Update last saved state of channels
   */
  updateState(): void {
    this.changeMade &#x3D; true;

    this.lastState &#x3D; {
      autoIncludeChannels: [...this.autoIncludeChannels],
      autoExcludeChannels: [...this.autoExcludeChannels],
      selectedChannels: [...this.selectedChannels],
    };
  }

  /**
   * Add channels to groups from csv
   *
   * @param channels new channels to add
   */
  addChannelsFromCSV(channels: Channel[]): void {
    this.rows &#x3D; [...channels];
    this.selectedChannels &#x3D; [...channels];
  }

  /**
   * Row selected on table
   *
   * @param selectedChannels all selected rows
   */
  selectRow(selectedChannels: Channel[]): void {
    this.showChannel &#x3D; selectedChannels[selectedChannels.length - 1];
    this.selectedChannels &#x3D; [...selectedChannels];
  }

  /**
   * Filters changed in the filter component
   *
   * @param searchFilters selected filters
   */
  filtersChanged(searchFilters: any): void {
    //clear all filters
    this.searchFilters &#x3D; searchFilters;

    //clear bounds if search filters emptied
    if (Object.keys(searchFilters).length &#x3D;&#x3D;&#x3D; 0) {
      this.bounds &#x3D; null;
    }

    this.getChannelsWithFilters();
  }

  /**
   * Request channels using the matching rules
   *
   * @param rules matching rules to search with
   */
  previewRules(rules: MatchingRule[]): void {
    this.error &#x3D; false;
    const params: any &#x3D; {};
    if (this.showOnlyCurrent) {
      const now &#x3D; this.dateService.now();
      params.endafter &#x3D; this.dateService.format(now);
    }
    if (rules &amp;&amp; rules.length &gt; 0) {
      const ruleSubs &#x3D; this.channelService.getChannelsByRules(rules, params);
      const results &#x3D; [];
      this.loadingService
        .doLoading(merge(...ruleSubs), this, LoadingIndicator.RESULTS)
        .pipe(
          tap((channels: Channel[]) &#x3D;&gt; {
            channels.forEach((channel) &#x3D;&gt; {
              const index &#x3D; results.findIndex((chan) &#x3D;&gt; chan.id &#x3D;&#x3D;&#x3D; channel.id);
              const excluded &#x3D; this.checkRules(channel, rules);
              if (index &lt; 0 &amp;&amp; !excluded &amp;&amp; channel) {
                results.push(channel);
              }
            });
          })
        )
        .subscribe({
          next: () &#x3D;&gt; {
            this.selectedChannels &#x3D; [...results];
            this.rows &#x3D; [...results];
            // add channels to selected Channels
          },
        });
    }
  }

  /**
   * Checks if channel should be included according to the given rules
   *
   * @param channel channel to check
   * @param rules rules to check
   * @returns true if channel should be excluded
   */
  private checkRules(channel: Channel, rules: MatchingRule[]): boolean {
    //excluded if any of them are true
    const excludeRules &#x3D; rules.filter((rule) &#x3D;&gt; rule.isInclude !&#x3D;&#x3D; true);

    if (excludeRules.length &#x3D;&#x3D;&#x3D; 0) {
      return false;
    }

    return excludeRules.every((rule: MatchingRule) &#x3D;&gt; {
      let net &#x3D; false;
      let sta &#x3D; false;
      let loc &#x3D; false;
      let chan &#x3D; false;
      if (rule.networkRegex) {
        net &#x3D; new RegExp(rule.networkRegex, &quot;i&quot;).test(channel.net);
      }
      if (rule.stationRegex) {
        sta &#x3D; new RegExp(rule.stationRegex, &quot;i&quot;).test(channel.sta);
      }
      if (rule.locationRegex) {
        loc &#x3D; new RegExp(rule.locationRegex, &quot;i&quot;).test(channel.loc);
      }
      if (rule.channelRegex) {
        chan &#x3D; new RegExp(rule.channelRegex, &quot;i&quot;).test(channel.code);
      }

      return net || sta || loc || chan;
    });
  }

  /**
   * Get channels with fitlers and/or bounds
   */
  getChannelsWithFilters(): void {
    const searchFilters &#x3D; { ...this.bounds, ...this.searchFilters };
    if (Object.keys(searchFilters).length !&#x3D;&#x3D; 0) {
      if (this.showOnlyCurrent) {
        const now &#x3D; this.dateService.now();
        searchFilters.endafter &#x3D; this.dateService.format(now);
      }
      this.error &#x3D; false;
      this.loadingService
        .doLoading(
          this.channelService.list(searchFilters),
          this,
          LoadingIndicator.RESULTS
        )
        .subscribe({
          next: (response) &#x3D;&gt; {
            this.selectedChannels &#x3D; [...response];
            this.rows &#x3D; [...response];
            //select retunred rows that are in group
          },
        });
    } else {
      this.selectedChannels &#x3D; [];
      this.rows &#x3D; [];
    }
  }

  /**
   * Saves channel group information
   */
  save(): void {
    const values &#x3D; this.channelGroupForm.value;
    const cg &#x3D; new ChannelGroup({
      id: this.id,
      name: values.name,
      description: values.description,
      organization: this.orgId,
      autoExcludeChannels: this.autoExcludeChannels,
      autoIncludeChannels: this.autoIncludeChannels,
      shareAll: this.shareAll,
      shareOrg: this.shareOrg,
    });

    /*
      Temp fix for channel groups not updating with channels on
      save unless there&#x27;s matching rules.
      Saves channels to group manually
    */
    if (this.matchingRules.length &#x3D;&#x3D;&#x3D; 0) {
      cg.channels &#x3D; [...cg.autoIncludeChannels];
    }
    let id;
    this.loadingService
      .doLoading(
        this.channelGroupService.updateOrCreate(cg).pipe(
          switchMap((groupId: number) &#x3D;&gt; {
            id &#x3D; groupId;
            if (
              this.matchingRules.length &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
              this.deleteMatchingRulesIds.length &#x3D;&#x3D;&#x3D; 0
            ) {
              return of([]);
            }
            this.matchingRules.forEach((m) &#x3D;&gt; {
              m.channelGroupId &#x3D; id;
            });
            return merge(
              ...this.matchingRuleService.updateOrDelete(
                this.matchingRules,
                this.deleteMatchingRulesIds
              )
            );
          })
        ),
        this,
        LoadingIndicator.MAIN
      )
      .subscribe({
        next: () &#x3D;&gt; {
          this.changeMade &#x3D; false;
          this.cancel(id);
          this.messageService.message(&quot;Channel group saved.&quot;);
        },
        error: () &#x3D;&gt; {
          this.messageService.error(&quot;Could not save channel group.&quot;);
        },
      });
  }

  /**
   * Deletes channel group
   */
  delete(): void {
    this.channelGroupService.delete(this.id).subscribe({
      next: () &#x3D;&gt; {
        this.cancel();
        this.messageService.message(&quot;Channel group deleted.&quot;);
      },
      error: () &#x3D;&gt; {
        this.messageService.error(&quot;Could not delete channel group&quot;);
      },
    });
  }

  /**
   * Cancels and exits edit page
   *
   * @param id group id
   */
  cancel(id?: number): void {
    if (id &amp;&amp; !this.id) {
      this.router.navigate([&quot;../&quot;, id], { relativeTo: this.route });
    } else {
      this.router.navigate([&quot;../&quot;], { relativeTo: this.route });
    }
  }

  /**
   * Checks if form has unsaved fields to prevent accidental navigation
   */
  formUnsaved(): void {
    if (this.channelGroupForm.dirty || this.changeMade) {
      this.confirmDialog.open({
        title: &quot;Cancel editing&quot;,
        message: &quot;You have unsaved changes, if you cancel they will be lost.&quot;,
        cancelText: &quot;Keep editing&quot;,
        confirmText: &quot;Cancel&quot;,
      });
      this.confirmDialog.confirmed().subscribe({
        next: (confirm) &#x3D;&gt; {
          if (confirm) {
            this.cancel();
          }
        },
      });
    } else {
      this.cancel();
    }
  }

  /**
   * Adds users searched params to the channel request
   *
   * @param filter search filter
   */
  addFilterToRegex(filter: SearchFilter): void {
    const newRule &#x3D; new MatchingRule();
    newRule.channelGroupId &#x3D; this.id;
    newRule.isInclude &#x3D; true;
    newRule.networkRegex &#x3D; filter.netSearch?.toUpperCase();
    newRule.stationRegex &#x3D; filter.staSearch?.toUpperCase();
    newRule.locationRegex &#x3D; filter.locSearch?.toUpperCase();
    newRule.channelRegex &#x3D; filter.chanSearch?.toUpperCase();
    this.matchingRules &#x3D; [...this.matchingRules, newRule];
  }

  /**
   * Delete channel group after confirming with user
   */
  onDelete(): void {
    this.confirmDialog.open({
      title: &#x60;Delete ${
        this.editMode ? this.channelGroup.name : &quot;Channel Group&quot;
      }&#x60;,
      message: &quot;Are you sure? This action is permanent.&quot;,
      cancelText: &quot;Cancel&quot;,
      confirmText: &quot;Delete&quot;,
    });
    this.confirmDialog.confirmed().subscribe({
      next: (confirm) &#x3D;&gt; {
        if (confirm) {
          this.delete();
        }
      },
    });
  }

  /**
   * Filter searched channels using the map bounds
   */
  filterBounds(): void {
    const temp &#x3D; this.selectedChannels.filter((channel) &#x3D;&gt; {
      const latCheck &#x3D;
        channel.lat &lt;&#x3D; this.bounds.latMax &amp;&amp; channel.lat &gt;&#x3D; this.bounds.latMin;
      const lonCheck &#x3D;
        channel.lon &gt;&#x3D; this.bounds.lonMin &amp;&amp; channel.lon &lt;&#x3D; this.bounds.lonMax;
      return latCheck &amp;&amp; lonCheck;
    });

    this.selectedChannels &#x3D; temp;
  }

  /**
   * Delete matching rules with given ids
   *
   * @param ids ids of rules to delete
   */
  deleteMatchingRules(ids: number[]): void {
    this.deleteMatchingRulesIds &#x3D; ids;
  }

  /**
   * Update bounds for filtering channels with map
   *
   * @param newBounds new bounds from map
   */
  updateBounds(newBounds: MapBounds): void {
    this.bounds &#x3D; newBounds;
    if (!this.bounds) {
      this.rows &#x3D; [...this.selectedChannels];
    } else {
      this.getChannelsWithFilters();
    }
  }

  /**
   * unsubscribe
   */
  ngOnDestroy(): void {
    this.subscriptions.unsubscribe();
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ChannelGroupForm.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
